<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS Ultra - Final</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-medium: #16213e;
            --bg-light: #0f3460;
            --primary-accent: #e94560;
            --secondary-accent: #53bf9d; /* Green for Win */
            --loss-color: #e74c3c;      /* Red for Lose */
            --text-color: #dcdcdc;
            --font-main: 'Poppins', sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-dark);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        header h1 {
            font-size: 2.5rem;
            color: var(--primary-accent);
            text-shadow: 0 0 10px var(--primary-accent);
        }

        .match-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            gap: 20px;
        }

        .player-card {
            background: var(--bg-medium);
            border-radius: 20px;
            padding: 20px;
            width: 280px;
            border: 2px solid var(--bg-light);
            transition: all 0.3s ease;
        }
        
        .player-card.winner {
            box-shadow: 0 0 25px var(--secondary-accent);
            border-color: var(--secondary-accent);
        }

        .player-card h2 { font-size: 1.5rem; margin-bottom: 15px; }
        .move-display {
            width: 120px; height: 120px;
            background: var(--bg-dark);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            margin: 15px auto;
            font-size: 4rem;
        }

        .score { font-size: 2rem; font-weight: 600; }

        .video-container {
            position: relative;
            width: 480px;
            height: 360px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #video, #overlay-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }

        /* --- ### FIX: Updated this rule for proper centering ### --- */
        .controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px; /* Adds space between text and button */
        }
        #countdown { font-size: 5rem; font-weight: 700; color: var(--primary-accent); height: 80px; line-height: 80px; }
        #countdown.animate { animation: countdown-pulse 1s ease forwards; }

        #start-button, #play-again-button {
            font-size: 1.5rem; padding: 15px 50px; cursor: pointer;
            border-radius: 50px; border: none;
            color: white; font-weight: 600;
            transition: all 0.2s ease;
        }
        #start-button { background-color: var(--primary-accent); }
        #start-button:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4); }
        
        .game-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s;
        }
        .game-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .result-card {
            background: var(--bg-medium);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.4s ease 0.2s;
        }
        .game-overlay.visible .result-card {
            transform: translateY(0);
            opacity: 1;
        }
        .result-card h1 { font-size: 3.5rem; font-weight: 700; }
        .result-card.win h1 { color: var(--secondary-accent); }
        .result-card.lose h1 { color: var(--loss-color); }
        .result-card.win { border-color: var(--secondary-accent); }
        .result-card.lose { border-color: var(--loss-color); }

        .final-score { font-size: 1.5rem; margin: 10px 0 30px 0; color: var(--text-color); }
        #play-again-button { background-color: var(--secondary-accent); }
        #play-again-button:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(83, 191, 157, 0.4); }

        @keyframes countdown-pulse { 0% { transform: scale(0.5); opacity: 0; } 50% { opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }
        
        @media (max-width: 900px) {
            .match-area { flex-direction: column; }
            .video-container { order: -1; margin-bottom: 20px; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <header><h1>RPS Ultra</h1></header>
        <div class="match-area">
            <div class="player-card" id="ai-card"><h2>YOLΛ AI</h2><div class="move-display" id="ai-move">?</div><p>Score: <span class="score" id="ai-score">0</span></p></div>
            <div class="video-container"><video id="video" autoplay playsinline></video><canvas id="overlay-canvas"></canvas></div>
            <div class="player-card" id="player-card"><h2>PLAYER O.P</h2><div class="move-display" id="player-move">?</div><p>Score: <span class="score" id="player-score">0</span></p></div>
        </div>
        <div class="controls"><div id="countdown">Press Start</div><button id="start-button">Start Game</button></div>
    </div>
    <canvas id="capture-canvas" style="display:none;"></canvas>

    <div class="game-overlay" id="game-over-screen">
        <div class="result-card" id="result-card">
            <h1 id="result-title"></h1>
            <p class="final-score" id="final-score"></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const captureCanvas = document.getElementById('capture-canvas');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const captureCtx = captureCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const playAgainButton = document.getElementById('play-again-button');
        const gameOverScreen = document.getElementById('game-over-screen');
        const moveEmojis = { rock: '✊', paper: '✋', scissors: '✌️' };
        let frameSenderInterval = null;

        // --- ### KEY FIX: Set canvas size after video loads ### ---
        video.addEventListener('loadedmetadata', () => {
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            overlayCanvas.width = videoWidth;
            overlayCanvas.height = videoHeight;
            captureCanvas.width = videoWidth;
            captureCanvas.height = videoHeight;
        });

        // --- WebSocket Setup ---
        const gameSocket = new WebSocket(`ws://${window.location.host}/ws/game/`);
        gameSocket.onmessage = (e) => handleServerMessage(JSON.parse(e.data));
        gameSocket.onopen = () => startButton.style.display = 'block';
        gameSocket.onclose = () => { document.getElementById('countdown').innerText = "Connection Lost!"; stopGame(); };

        function handleServerMessage(data) {
            switch (data.type) {
                case 'countdown': updateCountdown(data.value); break;
                case 'game_update': updateGameUI(data); drawHand(data.landmarks); break;
                case 'game_over': showGameOver(data); break;
            }
        }

        function drawHand(landmarks) {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            if (!landmarks || landmarks.length === 0) return;

            overlayCtx.fillStyle = '#ff00ff';
            landmarks.forEach(lm => {
                const x = overlayCanvas.width - lm[0];
                const y = lm[1];
                overlayCtx.beginPath();
                overlayCtx.arc(x, y, 5, 0, 2 * Math.PI);
                overlayCtx.fill();
            });
        }
        
        function sendFrame() {
            if (gameSocket.readyState !== WebSocket.OPEN) return;
            captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
            const imageData = captureCanvas.toDataURL('image/jpeg', 0.5);
            gameSocket.send(JSON.stringify({'type': 'frame', 'image': imageData}));
        }

        function startGame() {
            startButton.style.display = 'none';
            gameOverScreen.classList.remove('visible');
            resetUI();
            gameSocket.send(JSON.stringify({'type': 'start_game'}));
            frameSenderInterval = setInterval(sendFrame, 100);
        }

        function stopGame() { 
            if (frameSenderInterval) clearInterval(frameSenderInterval);
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }

        function showGameOver(data) {
            stopGame();
            const resultCard = document.getElementById('result-card');
            const resultTitle = document.getElementById('result-title');
            const finalScore = document.getElementById('final-score');
            const playerScore = document.getElementById('player-score').innerText;
            const aiScore = document.getElementById('ai-score').innerText;

            resultCard.className = 'result-card';
            if (data.winner === "Player") {
                resultTitle.innerText = "VICTORY";
                resultCard.classList.add('win');
            } else {
                resultTitle.innerText = "DEFEAT";
                resultCard.classList.add('lose');
            }
            finalScore.innerText = `Final Score: ${playerScore} - ${aiScore}`;
            gameOverScreen.classList.add('visible');
        }

        function updateCountdown(value) {
            const countdownEl = document.getElementById('countdown');
            countdownEl.innerText = value > 0 ? value : "SHOOT!";
            if (value === 3) {
                 overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            }
            countdownEl.classList.remove('animate');
            void countdownEl.offsetWidth;
            countdownEl.classList.add('animate');
        }

        function updateGameUI(data) {
            const playerMoveEl = document.getElementById('player-move');
            const aiMoveEl = document.getElementById('ai-move');
            const aiCard = document.getElementById('ai-card');
            const playerCard = document.getElementById('player-card');

            aiCard.classList.remove('winner');
            playerCard.classList.remove('winner');
            
            if (data.error) {
                playerMoveEl.innerText = '?';
            } else {
                playerMoveEl.innerText = moveEmojis[data.player_move] || '?';
                aiMoveEl.innerText = moveEmojis[data.ai_move] || '?';
                document.getElementById('ai-score').innerText = data.scores[0];
                document.getElementById('player-score').innerText = data.scores[1];
                if(data.player_move && data.ai_move) {
                    const winner = getWinner(data.player_move, data.ai_move);
                    if (winner === 'Player') playerCard.classList.add('winner');
                    if (winner === 'AI') aiCard.classList.add('winner');
                }
            }
        }

        function getWinner(player, ai) { if(!player || !ai || player === ai) return 'Tie'; return ({rock:'scissors', paper:'rock', scissors:'paper'})[player] === ai ? 'Player' : 'AI'; }
        
        function resetUI() {
            document.getElementById('player-score').innerText = '0';
            document.getElementById('ai-score').innerText = '0';
            document.getElementById('player-move').innerText = '?';
            document.getElementById('ai-move').innerText = '?';
            document.getElementById('countdown').innerText = '';
            document.getElementById('ai-card').classList.remove('winner');
            document.getElementById('player-card').classList.remove('winner');
        }

        startButton.addEventListener('click', startGame);
        playAgainButton.addEventListener('click', startGame);
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => { video.srcObject = stream; })
            .catch(err => { console.error("Error accessing webcam: ", err); });
    </script>
</body>
</html>